# -*- coding: utf-8 -*-
"""Projeto Final de PI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_BZun1ImskMcTi8AA5U-k3Ib3hc7vnGh

# **Processamento de Imagens - Trabalho Final**
--- 
Nome | RA 
:---------|:---------  
Bruno A. Veiga | 743514
Giulia S . Fazzi | 743542
Gustavo Padilha de Oliveira | 727297
Lucas S. A. Costa | 743563  
Thiago Borges da Silva | 613770

# **Introdução**

Um labirinto é uma área bidimensional constituída por caminhos e paredes dispostos de forma a dificultar a identificação da rota que liga a entrada à saída. Sua complexidade é determinada pelo número de paredes, de entradas, de corredores, pela diversidade de caminhos possíveis e pela distância entre o início e o término da estrutura. 


Neste projeto utilizaremos uma tranformação morfológica para resolver labirintos perfeitos, para então comparar a eficiência dessa solução com alguns outros algoritmos implementados na biblioteca [*mazelib*](https://github.com/theJollySin/mazelib).

# **Como executar o projeto?**
Esta seção contém informações sobre o Google Colab e sobre a execução do projeto.


# **Instalar e importar bibliotecas**
Nessa seção, ocorre a instalação e importação das bibliotecas a serem utilizadas.


---

Foi utilizada a biblioteca `mazelib` para geração dos labirintos e para as soluções que utilizam outros algoritmos que não sejam os de processamento de imagens.



> É possível que o output exiba uma mensagem indicando que deve ser "restartado". Não é preciso (nem recomendado) que isso seja feito nesse caso.

> É esperado que o output mostre alguns erros durante a instalação do `mazelib`. É normal, são apenas versões desatualizadas, logo em seguida alguns pacotes serão atualizados.
"""

# Instação das bibliotecas
!pip install mazelib

# Matplotlib: biblioteca para plotar imagens e gráficos
import matplotlib.pyplot as plt

# Mazelib: biblioteca para gerar e resolver labirintos
import mazelib
from mazelib import Maze
from mazelib.generate.Prims import Prims
from mazelib.solve.BacktrackingSolver import BacktrackingSolver
from mazelib.solve.Tremaux import Tremaux
from mazelib.solve.ShortestPath import ShortestPath
from mazelib.solve.RandomMouse import RandomMouse

# Skimage: biblioteca para lidar com imagens e convertê-las em arrays
from skimage.io import imread
from skimage.color import rgb2gray

# OpenCV: biblioteca para manipulação de imagens
import cv2

# Outras bibliotecas úteis para operações ao longo da execução
import numpy as np
import time
import os, psutil
from copy import deepcopy

"""# **Definição de funções**

A seguir são definidas diversas funções que serão utilizadas ao decorrer das execuções.



---

## **`exibirPNG`: plota o labirinto**

Parâmetros:

> `grid`: array referente ao labirinto


> `salvarImagem` (Opcional): booleano indicando se a imagem deve ser salva (em PNG) no diretório. Por default é `False`
"""

def exibirPNG(grid, salvarImagem=False):
    plt.figure(figsize=(10, 5))
    plt.imshow(grid, cmap=plt.cm.binary, interpolation='nearest')
    plt.xticks([]), plt.yticks([])
    plt.axis('off')

    if (salvarImagem):
      plt.savefig('maze-saved.png', bbox_inches = 'tight', pad_inches = 0)

    plt.show()

"""## **`gerarLabirinto`: gera o labirinto utilizando `mazelib`**

Parâmetros:

> `tamanho` (Opcional): inteiro indicando o tamanho do labirinto. Por default é `20`

Retorno:
> `m`: retorna a instância da classe labirinto, que será utilizada pelos demais algoritmos




"""

def gerarLabirinto(tamanho=20):
  m = Maze()
  # Utiliza o algoritmo de Prims para a geração do labirinto
  m.generator = Prims(tamanho, tamanho)
  m.generate()
  
  # Gera entrada e saída aleatórias no labirinto
  m.generate_entrances()

  # Remove a borda do labirinto no local de entrada
  h = m.start[0]
  w = m.start[1]
  m.grid[h,w] = 0

  # Remove a borda do labirinto no local de saída
  h = m.end[0]
  w = m.end[1]
  m.grid[h,w] = 0

  exibirPNG(grid=m.grid, salvarImagem=True)

  return m

"""## **`metricas`: calcula as métricas de execução do algoritmo**

Parâmetros:
> `start_time`: horário em que o algoritmo foi iniciado

> `dict_metr`: dicionário que armazena as métricas

> `algoritmo`: algoritmo que está sendo analisado




"""

def metricas(start_time, dict_metr, algoritmo):
  # Inicializa dicionário com as métricas obtiidas
  metr = {
      "Tempo de execução": (time.time() - start_time),
      "RAM": (psutil.Process(os.getpid()).memory_info().rss / 1024 ** 2)
  }

  #  Atribui métricas à chave com nome do algoritmo
  dict_metr[algoritmo] = metr

  # Exibe métricas
  print("--- %0.5f seconds ---" % (metr["Tempo de execução"]))
  print("--- %0.5f MB of RAM used ---" % (metr["RAM"]))

"""## **`graficosMetricas`: exibe gráficos com as métricas obtidas**

Parâmetros:
> `dict_metr`: dicionário que armazena as métricas




"""

def graficosMetricas(dict_metr):
  algs = list(dict_metr.keys())
  alg_exemplo = algs[0]
  metrs = list(dict_metr[alg_exemplo].keys())

  for metr in metrs:
    plt.figure(figsize=(15, 5))
    for idx, alg in enumerate(algs):
      plt.bar(idx,dict_metr[alg][metr],tick_label=alg)
      
    plt.title(metr)
    plt.xticks(range(0,len(algs)),algs)
    plt.show()

"""## **`exibirCaminho`: plota o labirinto com a solução**

Parâmetros:
> `labirinto`: array referente ao labirinto




"""

def exibirCaminho(labirinto):
  img = deepcopy(labirinto)
  img = img.grid

  # Deixa o labirinto em cinza e marca o caminho em preto
  for coord in labirinto.solutions[0]: 
    h = 1*(coord[0]+1)
    w = 1*(coord[1]+1)
    h0= 1*coord[0]
    w0= 1*coord[1] 
    img[h0:h,w0:w] = img[h0:h,w0:w]+2

  img[h0:coord[0]+1,w0:w]

  # Adiciona a entrada à exibição
  h = 1*(labirinto.start[0])
  w = 1*(labirinto.start[1])
  img[h,w] = 2

  # Adiciona a saída à exibição
  h = 1*(labirinto.end[0])
  w = 1*(labirinto.end[1])
  img[h,w] = 2

  # PLota o labirinto
  exibirPNG(img)

"""## **`carregarLabirinto`: carrega o labirinto a partir de uma imagem PNG e a transforma em um array**

Parâmetros:
> `arquivo` (Opcional): string contendo o endereço e nome da imagem a ser carregada. Por default é `'maze-saved.png'`, mesmo nome que a função de geração de labirinto usa para salvar o arquivo.

Retorno:
> `img`: retorna o labirinto como um array, em que 0 indica parede e 255 indica espaço vazio.

> `binary_image`: retorna o labirinto como um array, em que 0 indica espaço vazio e 1 indica parede.




"""

def carregarLabirinto(arquivo='maze-saved.png'):
  img = cv2.imread(arquivo)
  process = psutil.Process(os.getpid())
  #binariza a imagem
  retval, binary_image=cv2.threshold(img, 10,255, cv2.THRESH_BINARY_INV)
  #converte para o formato do cv2
  binary_image = cv2.cvtColor(binary_image, cv2.COLOR_BGR2GRAY)

  return img, binary_image

"""## **`exibirSolucao`: plota a solução do labirinto combinada com a imagem original**

Parâmetros:
> `img`: array contendo o labirinto e a solução encontrada

> `diff`: array contendo a subtração da matriz dilatada com a erodida




"""

def exibirSolucao(img, diff):
  # #################################################### #
  # Combina a solução do labirinto com a imagem original #
  # #################################################### #
  #separa a imagem nos canais de RGB
  channels=cv2.split(img)

  #realiza a operações logica AND NOT no primeiro e no segundo canal (vermelho e verde)
  channels[0] = channels[0] & ~diff
  channels[1] = channels[1] & ~diff

  #realiza a operações logica OR terceiro canal (azul)
  channels[2] = channels[2] | diff

  #combina os canais em uma nova imagem
  solution = cv2.merge(channels)

  #exibi a solução do labirinto
  fig = plt.figure(figsize=(8, 8))
  fig.text(.5, .05, "Figura 3: Sobreposição do caminho na imagem original", ha='center')
  ax = plt.gca()
  ax.axes.xaxis.set_ticklabels([])
  ax.axes.yaxis.set_ticklabels([])
  plt.imshow(solution, interpolation='nearest', cmap=plt.cm.gray)

"""## **`morfMat`: executa o algoritmo de morfologia matemática para resolver o labirinto**

Parâmetros:
> `img`: array do labirinto, em que 0 indica parede e 255 indica espaço vazio.

> `binary_image`: array do labirinto, em que 0 indica espaço vazio e 1 indica parede.

Retorno:
> `diff`: retorn o array contendo a subtração da matriz dilatada com a erodida




"""

def morfMat(imagem, imagem_binaria):
  img = imagem.copy()
  binary_image = imagem_binaria.copy()

  # ############################## #
  # Separa as paredes do labirinto #
  # ############################## #

  # Marca o horário ao iniciar o algoritmo
  start = time.time()

  #calcula os contornos para separar as duas paredes do labirinto
  contours, hierarchy=cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
  h, w, d = img.shape

  #cria imagens vazias da dimensão do labirinto
  wall_1=np.zeros((h, w), dtype=np.uint8) #cv2.cv_8uc1
  wall_2=np.zeros((h, w), dtype=np.uint8) #cv2.cv_8uc1

  #insere os contornos calculados nas imagens vazias
  cv2.drawContours(wall_1, contours, 0, (255,255,255),-1) #cv2.filled
  cv2.drawContours(wall_2, contours, 1, (255,255,255),-1) #cv2.filled

  # #################################################### #
  # Operações de dilatação, erosão e subtração da parede #
  # #################################################### #

  #aplica dilatação na primeira parede isolada
  kernel=np.ones((17, 17), dtype=np.uint8)
  wall_1_dilated=cv2.dilate(wall_1, kernel)

  #aplica erosão na parede dilatada
  wall_1_dilated_eroded=cv2.erode(wall_1_dilated, kernel)

  #subtrai a parede erodida da parede dilatada
  diff= cv2.absdiff(wall_1_dilated, wall_1_dilated_eroded)

  
  # Exibe as métricas
  metricas(start, valores_metricas, "Morfologia Matemática")

  #exibe as duas paredes separadas
  fig, axes = plt.subplots(1, 2, figsize=(16, 8))
  fig.text(.5, .05, "Figura 1: Separação do labirinto em duas paredes", ha='center')

  ax = axes.ravel()
  ax[0].axis('off')
  ax[0].imshow(wall_1, interpolation='nearest', cmap=plt.cm.gray)
  ax[1].axis('off')
  ax[1].imshow(wall_2, interpolation='nearest', cmap=plt.cm.gray)
  
  fig, axes = plt.subplots(1, 3, figsize=(16, 6))
  ax = axes.ravel()

  fig.text(.5, .05, "Figura 2: Obtenção de caminho", ha='center')

  #exibe a parede dilatada, a parede erodida e o caminho resultante da substração
  ax[0].set_xlabel('(a) Parede dilatada')
  ax[0].axes.xaxis.set_ticks([])
  ax[0].axes.yaxis.set_ticks([])
  ax[0].imshow(wall_1_dilated, interpolation='nearest', cmap=plt.cm.gray)

  ax[1].set_xlabel('(b) Parede erodida')
  ax[1].axes.xaxis.set_ticks([])
  ax[1].axes.yaxis.set_ticks([])
  ax[1].imshow(wall_1_dilated_eroded, interpolation='nearest', cmap=plt.cm.gray)

  ax[2].set_xlabel('(c) Caminho resultante da diferença entre parede \n erodida e dilatada')
  ax[2].axes.xaxis.set_ticks([])
  ax[2].axes.yaxis.set_ticks([])
  ax[2].imshow(diff, interpolation='nearest', cmap=plt.cm.gray)
  
  return diff

"""# **Criação do labirinto**

Um labirinto perfeito (com 2 paredes e sem ciclos) é gerado. Os algoritmos seguintes usarão esse mesmo labirinto gerado.
"""

lab = gerarLabirinto()

"""Também será inicializado um dicionário para armazenar os valores encontrados de métricas de desempenho."""

valores_metricas = {}

"""# **Morfologia matemática**

Transformações morfológicas são operações em que a ideia é percorrer a imagem com um chamado "elemento estruturante" e avaliar como tal elemento se encaixa na imagem, em um determinado ponto. Essa avaliação é definida pelas *operações morfológicas*. Duas operações morfológicas básicas que destacamos são a Erosão e a Dilatação.  

A erosão de um conjunto de pixels A por B é o conjunto de todos os pontos x tal que B, transladado por x, está contido em A. Tal conjunto tem seus pixels assumindo o valor 0 caso a condição seja satisfeita, o que faz "o tamanho" de A diminuir. 

Já a dilatação de um conjunto de pixels A por B é um conjunto de todo os deslocamentos de x tal que B sobrepõe pelo menos um elemento não nulo de A. O resultado disso é um "aumento" no tamanho de A. A estratégia que usaremos para resolver os labirintos consiste em:
1. dividir o labirinto em duas partes
2. dilatar o contorno das paredes do labirinto de um lado
3. erodir o contorno, na mesma proporção.
4. tirar a diferenca entre as imagens resultantesd dos tópicos 2 e 3

O resultado de 4 consistirá no nosso labirinto.

O grupo optou por fazer a implementação desse algoritmo de Processamento de Imagens por ter apresentado um ótimo desempenho em [[1]](https://ojs2.ifes.edu.br/index.php/ric/article/view/864).
"""

# Faz a leitura da imagem a partir de um arquivo PNG
img, bin_img = carregarLabirinto()

# Executa o algoritmo para encontrar a solução do labirinto
solucao = morfMat(img, bin_img)

# Exibe o caminho encontrado
exibirSolucao(img, solucao)

"""# **Recursive Backtracker**

É rápido para todos os tipos de labirinto. Se você estiver em uma parede ou uma área que já traçou, retorna fracasso; do contrário, se estiver no final, retorna sucesso, senão tenta mover-se recursivamente nas quatro direções. Traça uma linha ao tentar uma nova direção e apaga uma linha quando retornar fracasso, e uma única solução será marcada quando você atingir o sucesso. Em termos de computação, funciona como busca em profundidade.  
Este método sempre encontrará uma solução, se houver, mas não será necessariamente a solução mais curta.

Resolução do labirinto utilizando o algoritmo BacktrackingSolver, fazendo uso da biblioteca `mazelib`
"""

# Faz uma cópia do labirinto gerado, para que o original não seja alterado e outros algoritmos possam fazer uso
lab_btsolver = deepcopy(lab)

# Instancia o algoritmo que resolverá o labirinto
lab_btsolver.solver = BacktrackingSolver()

# Marca o horário ao iniciar o algoritmo
start = time.time()

# Resolve
lab_btsolver.solve()

# Exibe as métricas
metricas(start, valores_metricas, "Recursive Backtracker")

# Exibe o caminho encontrado
exibirCaminho(lab_btsolver)

"""# **Trémaux**

Este método encontrará uma solução para todos os labirintos. Conforme você caminha por uma passagem, desenha uma linha atrás de você para marcar seu caminho. Quando você chegar a um beco sem saída, dê meia-volta e volte pelo caminho de onde veio. Quando encontrar um cruzamento que não tenha sido visitado antes, escolhe uma nova passagem aleatoriamente. Se estiver caminhando por uma nova passagem e encontrar um cruzamento que já visitou, trata-o como um beco sem saída e volta pelo caminho por onde veio, esse passo o impede de andar em círculos. Se estiver caminhando por uma passagem que já visitou e encontrar um cruzamento, escolhe qualquer nova passagem, se houver disponível, caso contrário, pega uma passagem antiga.

Resolução do labirinto utilizando o algoritmo Tremaux, fazendo uso da biblioteca `mazelib`
"""

# Faz uma cópia do labirinto gerado, para que o original não seja alterado e outros algoritmos possam fazer uso
lab_tremaux = deepcopy(lab)

# Instancia o algoritmo que resolverá o labirinto
lab_tremaux.solver = Tremaux()

# Marca o horário ao iniciar o algoritmo
start = time.time()

# Resolve
lab_tremaux.solve()

# Exibe as métricas
metricas(start, valores_metricas, "Trémaux")

# Exibe o caminho encontrado
exibirCaminho(lab_tremaux)

"""# **Shortest Path**

Esse algoritmo encontra o caminho mais curto, escolhendo um se houver várias soluções mais curtas. É rápido para todos os tipos de labirinto e requer memória extra, proporcional ao tamanho do labirinto. Ele basicamente inunda o labirinto com "água", de modo que todas as distâncias desde o início são preenchidas ao mesmo tempo, porém cada "gota" ou pixel lembra por qual pixel foi preenchido. Assim que a solução for atingida por uma "queda" (saída), rastreia de volta ao início e é definidio então o caminho mais curto.

Resolução do labirinto utilizando o algoritmo ShortestPath, fazendo uso da biblioteca `mazelib`
"""

# Faz uma cópia do labirinto gerado, para que o original não seja alterado e outros algoritmos possam fazer uso
lab_short = deepcopy(lab)

# Instancia o algoritmo que resolverá o labirinto
lab_short.solver = ShortestPath()

# Marca o horário ao iniciar o algoritmo
start = time.time()

# Resolve
lab_short.solve()

# Exibe as métricas
metricas(start, valores_metricas, "Shortest Path")

# Exibe o caminho encontrado
exibirCaminho(lab_short)

"""# **Random Mouse**

Esse é um método considerado ineficiente, que consiste basicamente em mover-se aleatoriamente, ou seja, mover-se em uma direção e seguir essa passagem por quaisquer curvas até chegar ao próximo cruzamento. Não são feitas curvas de 180 graus, a menos que seja necessário. É lento e não é garantido que termine ou resolva o labirinto, e uma vez que o fim seja alcançado, será igualmente difícil refazer seus passos, mas é definitivamente simples e não requer nenhuma memória extra para implementar.

Resolução do labirinto utilizando o algoritmo RandomMouse, fazendo uso da biblioteca `mazelib`
"""

# Faz uma cópia do labirinto gerado, para que o original não seja alterado e outros algoritmos possam fazer uso
lab_mouse = deepcopy(lab)

# Instancia o algoritmo que resolverá o labirinto
lab_mouse.solver = RandomMouse()

# Marca o horário ao iniciar o algoritmo
start = time.time()

# Resolve
lab_mouse.solve()

# Exibe as métricas
metricas(start, valores_metricas, "Random Mouse")

# Exibe o caminho encontrado
exibirCaminho(lab_mouse)

"""# **Métricas**

Para obter resultados mais precisos em fins de métricas, recomenda-se que o projeto seja executado dversas vezes, gerando diferentes labirintos, pois é possível que, por coincidência, um algoritmo que não tem um comportamento muito rápido acabe se comportando bem em algum dos labirintos gerados, considerando a aleatoriedade do algoritmo de criação.
"""

graficosMetricas(valores_metricas)

"""Algoritmo | Número de soluções | Humanizável | Solução garantida | Menor caminho | Rápido
:---------|:---------|:---------|:---------|:---------|:---------
Morfologia matemática | 1 | não | sim | sim | sim
Recursive Backtracker | 1 | não | sim | não | sim
Trémaux | 1 | sim |  sim | não | sim
Shortest Path | 1 | não | sim | sim | sim
Random Mouse | 1 | sim | não | não | não

As descrições das colunas são as seguintes:


*   **Número de soluções:** Número encontrado de soluções após a execução do algoritmo.
*   **Humanizável:** Esse parâmetro diz sobre a possibilidade de uma pessoa usar esse algoritmo para encontrar a solução do labirinto.
*   **Solução garantida:** Garantia de que um caminho será encontrado ao final da execução do algoritmo.
*   **Menor caminho:** Indica se o caminho encontrado é o menor possível dentre as soluções.
*   **Rápido:** Indica se o processo de resolução é considerado rápido.

# **Referências**

*   [1] [Comparação de algoritmos de processamento digital de imagens aplicadas à resolução de labirintos bidimensionais](https://ojs2.ifes.edu.br/index.php/ric/article/view/864)
*   [2] [Maze Classification](https://www.astrolog.org/labyrnth/algrithm.htm)
*   [3] [Documentação e código fonte da biblioteca mazelib](https://github.com/theJollySin/mazelib)
*   [4] [Implementação em MATLAB do algoritmo de resolução de labirintos utilizando morfologia matemática ](https://www.crisluengo.net/archives/277)
"""